/************************************************

        WARNING: MACHINE GENERATED FILE

 ************************************************/
import Foundation
import State
<$foreach Attribute noninheritedAttributes do$><$if Attribute.userInfo.State.Import$>import <$Attribute.userInfo.State.Import$>
<$endif$><$endforeach$>

<$set transientAttributeCount = 0$><$foreach Attribute noninheritedAttributes do$><$if Attribute.isTransient$><$set transientAttributeCount = transientAttributeCount + 1$><$endif$><$endforeach do$>

<$set transientRelationshipCount = 0$><$foreach Relationship noninheritedRelationships do$><$if Relationship.isTransient$><$set transientRelationshipCount = transientRelationshipCount + 1$><$endif$><$endforeach do$>

<$procedure getTypeForAttribute Attribute$><$if Attribute.userInfo.State.Type$><$Attribute.userInfo.State.Type$><$elseif Attribute.hasScalarAttributeType$><$if Attribute.scalarAttributeType == Int16 || Attribute.scalarAttributeType == Int32 || Attribute.scalarAttributeType == Int64$>Int<$else$><$Attribute.scalarAttributeType$><$endif$><$else$><$Attribute.objectAttributeType$><$endif$><$if Attribute.isOptional$>?<$endif$><$endprocedure$>

<$procedure writeAttributeDefaultValue Attribute DefaultValue$><$if Attribute.userInfo.State.Type$><$if Attribute.userInfo.State.Type == String$>"<$endif$><$DefaultValue$><$if Attribute.userInfo.State.Type == String$>"<$endif$><$else$><$if Attribute.objectAttributeType == String$>"<$endif$><$DefaultValue$><$if Attribute.objectAttributeType == String$>"<$endif$><$endif$><$endprocedure$>

<$procedure getDefaultExpressionForAttribute Attribute$> <$setlocal default = none$><$if Attribute.userInfo.State.Value$>= <$call writeAttributeDefaultValue Attribute Attribute.userInfo.State.Value$><$elseif Attribute.defaultValue !=$>= <$call writeAttributeDefaultValue Attribute Attribute.defaultValue$><$endif$><$endprocedure$>

<$procedure writeRelationshipDefaultValue Relationship DefaultValue$><$if Relationship.userInfo.State.Type$><$if Relationship.userInfo.State.Type == String$>"<$endif$><$endif$><$DefaultValue$><$if Relationship.userInfo.State.Type$><$if Relationship.userInfo.State.Type == String$>"<$endif$><$endif$><$endprocedure$>

<$procedure getDefaultExpressionForRelationship Relationship$><$if Relationship.userInfo.State.Value$>= <$call writeRelationshipDefaultValue Relationship Relationship.userInfo.State.Value$><$endif$><$endprocedure$>

<$procedure getPropertyDeclarationForAttribute Attribute$><$if Attribute.userInfo.State.Immutable == YES$>public let<$else$>public var<$endif$> <$Attribute.name$><$if  !Attribute.isOptional && (Attribute.userInfo.State.Value || Attribute.defaultValue !=)$><$call getDefaultExpressionForAttribute Attribute$><$else$>: <$call getTypeForAttribute Attribute$><$endif$><$endProcedure$>

<$procedure getPropertyDeclarationForRelationship Relationship$><$if Relationship.userInfo.State.Immutable == YES$>public let<$else$>public var<$endif$> <$Relationship.name$><$if !Relationship.isOptional && Relationship.userInfo.State.Value$> <$call getDefaultExpressionForRelationship Relationship$><$else$>: <$if Relationship.isToMany$>[<$if Relationship.userInfo.State.CompositionType == Dictionary$>String : <$endif$><$endif$><$Relationship.destinationEntity.managedObjectClassName$><$if Relationship.isToMany$>]<$endif$><$if Relationship.isOptional$>?<$endif$><$endif$><$endProcedure$>

<$procedure writeVersionHashExtension$>
extension <$typeName$> {

    /// These are provided from the data model designer
    /// and can be used to determine if the model is
    /// a different version.
    public static func modelVersionHash() -> String {
        return "<$versionHash$>"
    }

    public static func modelVersionHashModifier() -> String? {
        return <$if versionHashModifier$>"<$versionHashModifier$>"<$else$>nil<$endif$>
    }
}<$endprocedure$>

<$procedure writeEncodingVersioningBlock$>
        <$typeName$>.encodeVersionIfNeeded(encoder)
        <$endprocedure$>

<$procedure writeDecodingMigrationBlock$>

    decoder = <$typeName$>.performMigrationIfNeeded(decoder)
    <$endprocedure$>

<$procedure Struct$>

<$setmerge typeName = <$managedObjectClassName$>$>
<$setmerge superTypeName = <$if isAbstract || userInfo.State.Protocol$><$managedObjectClassName$>
<$elseif hasSuperentity$><$superentity.managedObjectClassName$><$else$>Model<$endif$>$>

public struct <$typeName$> : <$superTypeName$> {
    <$foreach Attribute attributesByName do$><$call getPropertyDeclarationForAttribute Attribute$>
    <$endforeach do$><$foreach Relationship relationshipsByName do$><$call getPropertyDeclarationForRelationship Relationship$>
    <$endforeach do$>

public init(<$foreach Attribute attributesByName do$><$if !Attribute.isTransient$><$Attribute.name$>: <$call getTypeForAttribute Attribute$><$if (AttributeIndex + 1) < (attributesByName.@count - transientAttributeCount)$>, <$endif$><$endif$><$endforeach do$><$if attributesByName.@count - transientAttributeCount > 0 && relationshipsByName.@count - transientRelationshipCount > 0$>, <$endif$><$foreach Relationship relationshipsByName do$><$if !Relationship.isTransient$><$if ! Relationship.isToMany$><$Relationship.name$>: <$Relationship.destinationEntity.managedObjectClassName$><$if Relationship.isOptional$>?<$endif$><$if (RelationshipIndex + 1 < relationshipsByName.@count - transientRelationshipCount) $>, <$endif$><$else$><$Relationship.name$>: [<$if Relationship.userInfo.State.CompositionType == Dictionary$>String : <$endif$><$Relationship.destinationEntity.managedObjectClassName$>]<$if Relationship.isOptional$>?<$endif$><$if (RelationshipIndex + 1 < relationshipsByName.@count - transientRelationshipCount) $>, <$endif$><$endif$><$endif$><$endforeach do$>) {

    <$foreach Attribute attributesByName do$><$if !Attribute.isTransient$>self.<$Attribute.name$> = <$Attribute.name$><$endif$>
    <$endforeach do$><$foreach Relationship relationshipsByName do$><$if !Relationship.isTransient$>self.<$Relationship.name$> = <$Relationship.name$><$endif$>
    <$endforeach do$>
    }
}

extension <$typeName$> : Decodable {

    static func create<$foreach Attribute attributesByName do$><$if !Attribute.isTransient$>(<$Attribute.name$>: <$call getTypeForAttribute Attribute$>)<$endif$><$endforeach do$><$foreach Relationship relationshipsByName do$><$if !Relationship.isTransient$><$if ! Relationship.isToMany$>(<$Relationship.name$>: <$Relationship.destinationEntity.managedObjectClassName$><$if Relationship.isOptional$>?<$endif$>)<$else$>(<$Relationship.name$>: [<$if Relationship.userInfo.State.CompositionType == Dictionary$>String : <$endif$><$Relationship.destinationEntity.managedObjectClassName$>]<$if Relationship.isOptional$>?<$endif$>)<$endif$><$endif$><$endforeach do$> -> <$typeName$>  {
        return <$typeName$>(<$foreach Attribute attributesByName do$><$if !Attribute.isTransient$><$Attribute.name$>: <$Attribute.name$><$if AttributeIndex + 1 < attributesByName.@count - transientAttributeCount$>, <$endif$><$endif$><$endforeach do$><$if (attributesByName.@count - transientAttributeCount) > 0 && (relationshipsByName.@count - transientRelationshipCount) > 0$>, <$endif$><$foreach Relationship relationshipsByName do$><$if !Relationship.isTransient$><$Relationship.name$>: <$Relationship.name$><$if (RelationshipIndex + 1 < relationshipsByName.@count - transientRelationshipCount) $>, <$endif$><$endif$><$endforeach do$>)
    }

    public init?(var decoder: Decoder) {

        <$call writeDecodingMigrationBlock$>

        let instance: <$typeName$>? = <$typeName$>.create
        <$setlocal firstNonTransientAttribute = 0$><$setlocal firstNonTransientRelationship = 0$><$foreach Attribute attributesByName do$><$if !Attribute.isTransient$><$if firstNonTransientAttribute == 0$><$setlocal firstNonTransientAttribute = 1$><$else$><$setlocal firstNonTransientAttribute = 2$><$endif$><$if firstNonTransientAttribute == 1$><^><$else$><*><$endif$> decoder.decode("<$Attribute.name$>")<$if Attribute.attributeType == 1800$> >>> <$Attribute.valueTransformerName$>.reverseTransform<$endif$><$if Attribute.isOptional$> >>> asOptional<$endif$><$endif$>
        <$endforeach do$><$foreach Relationship relationshipsByName do$><$if !Relationship.isTransient$><$if firstNonTransientRelationship == 0$><$setlocal firstNonTransientRelationship = 1$><$else$><$setlocal firstNonTransientRelationship = 2$><$endif$><$if firstNonTransientRelationship == 1 && firstNonTransientAttribute == 0$><^><$else$><*><$endif$> decoder.decode<$if Relationship.destinationEntity.isAbstract || Relationship.destinationEntity.userInfo.State.Protocol == YES$><$Relationship.destinationEntity.managedObjectClassName$><$else$>Model<$endif$><$if Relationship.isToMany$><$if Relationship.userInfo.State.CompositionType == Dictionary$>Dictionary<$else$>Array<$endif$><$endif$>("<$Relationship.name$>")<$if Relationship.isOptional$> >>> asOptional<$endif$><$endif$>
        <$endforeach do$>
        if let i = instance {
            i.didFinishDecodingWithDecoder(decoder)
            self = i
        } else { return nil }
    }
}

extension <$typeName$> : Encodable {

    public func encode(encoder: Encoder) {
        <$foreach Attribute attributesByName do$><$if !Attribute.isTransient$>encoder.encode(<$Attribute.name$><$if Attribute.attributeType == 1800$> >>> <$Attribute.valueTransformerName$>.transform<$endif$>, "<$Attribute.name$>")
        <$endif$><$endforeach do$><$foreach Relationship relationshipsByName do$><$if !Relationship.isTransient$>encoder.encode(<$Relationship.name$>, "<$Relationship.name$>")
        <$endif$><$endforeach do$>
        <$if hasSuperentity$>encoder.encode("<$typeName$>", model_type_key)<$endif$>
        <$call writeEncodingVersioningBlock$>
        self.willFinishEncodingWithEncoder(encoder)
    }
}

<$call writeVersionHashExtension $>
<$endprocedure$>


<$procedure writeRawValueCaseForAttribute Attribute$><$if Attribute.userInfo.State.Value$> = <$if userInfo.State.Type == String$>"<$endif$><$ Attribute.userInfo.State.Value$><$if userInfo.State.Type == String$>"<$endif$><$endif$><$endprocedure$>

<$procedure writeAssociatedValueCaseForAttribute Attribute$><$if Attribute.userInfo.State.Type$>(<$Attribute.userInfo.State.Type$><$if Attribute.isOptional$>?<$endif$>)<$endif$><$endprocedure$>

<$procedure writeEnumCaseForAttribute Attribute$>case <$Attribute.name.initialCapitalString$> <$if userInfo.State.Type$><$call writeRawValueCaseForAttribute Attribute$><$else$><$call writeAssociatedValueCaseForAttribute Attribute$><$endif$><$endprocedure$>


<$procedure writeRawValueCaseForRelationship Relationship$><$if Relationship.userInfo.State.Value$> = <$if userInfo.State.Type == String$>"<$endif$><$ Relationship.userInfo.State.Value$><$if userInfo.State.Type == String$>"<$endif$><$endif$><$endprocedure$>

<$procedure writeAssociatedValueCaseForRelationship Relationship$><$if Relationship.destinationEntity.managedObjectClassName$>(<$if Relationship.isToMany$>[<$endif$><$Relationship.destinationEntity.managedObjectClassName$><$if Relationship.isToMany$>]<$endif$><$if Relationship.isOptional$>?<$endif$>)<$endif$><$endprocedure$>


<$procedure writeEnumCaseForRelationship Relationship$>case <$Relationship.name.initialCapitalString$> <$if userInfo.State.Type$><$call writeRawValueCaseForRelationship Relationship$><$else$><$call writeAssociatedValueCaseForRelationship Relationship$><$endif$><$endprocedure$>


<$procedure writeAttributeDecodeAssociatedSwitchCaseForEnum Attribute$>if let value: <$Attribute.userInfo.State.Type$><$if Attribute.isOptional$>?<$endif$> = decoder.decode("value")<$if Attribute.attributeType == 1800$> >>> <$Attribute.valueTransformerName$>.reverseTransform<$endif$><$if Attribute.isOptional$> >>> asOptional<$endif$> {
                        self = <$typeName$>.<$Attribute.name.initialCapitalString$>(value)
                    } else { return nil }<$endprocedure$>

<$procedure writeAttributeDecodeBasicSwitchCaseForEnum Attribute$>self = <$typeName$>.<$Attribute.name.initialCapitalString$><$endprocedure$>

<$procedure writeAttributeDecodeRawSwitchCaseForEnum Attribute$>if let value: <$userInfo.State.Type$> = decoder.decode("value"),
                        instance = <$typeName$>(rawValue: value) {
                        instance.didFinishDecodingWithDecoder(decoder)
                        self = instance
                    } else { return nil }<$endprocedure$>

<$procedure writeAttributeDecodeSwitchCaseForEnumCase Attribute$>case "<$Attribute.name.initialCapitalString$>":
                    <$if userInfo.State.Type$><$call writeAttributeDecodeRawSwitchCaseForEnum Attribute$><$elseif Attribute.userInfo.State.Type$><$call writeAttributeDecodeAssociatedSwitchCaseForEnum Attribute$><$else$><$call writeAttributeDecodeBasicSwitchCaseForEnum Attribute$><$endif$><$endprocedure$>

<$procedure writeRelationshipDecodeAssociatedSwitchCaseForEnum Relationship$>if let value: <$if Relationship.isToMany$>[<$endif$><$Relationship.destinationEntity.managedObjectClassName$><$if Relationship.isToMany$>]<$endif$><$if Relationship.isOptional$>?<$endif$> = decoder.decodeModel<$if Relationship.isToMany$>Array<$endif$>("value") <$if Relationship.isOptional$>>>> asOptional<$endif$>{
                        self = <$typeName$>.<$Relationship.name.initialCapitalString$>(value)
                    } else { return nil }<$endprocedure$>

<$procedure writeRelationshipDecodeBasicSwitchCaseForEnum Relationship$>self = <$typeName$>.<$Relationship.name.initialCapitalString$><$endprocedure$>

<$procedure writeRelationshipDecodeRawSwitchCaseForEnum Relationship$>if let value: <$userInfo.State.Type$> = decoder.decodeModel<$if Relationship.isToMany$>Array<$endif$>("value"),
                        instance = <$typeName$>(rawValue: value) {
                        instance.didFinishDecodingWithDecoder(decoder)
                        self = instance
                    } else { return nil }<$endprocedure$>

<$procedure writeRelationshipDecodeSwitchCaseForEnumCase Relationship$>case "<$Relationship.name.initialCapitalString$>":
                    <$if userInfo.State.Type$><$call writeRelationshipDecodeRawSwitchCaseForEnum Relationship$><$elseif  Relationship.destinationEntity.managedObjectClassName$><$call writeRelationshipDecodeAssociatedSwitchCaseForEnum Relationship$><$else$><$call writeRelationshipDecodeBasicSwitchCaseForEnum Relationship$><$endif$><$endprocedure$>

<$procedure writeAttributeEncodeBasicSwitchCaseForEnum Attribute$>case .<$Attribute.name.initialCapitalString$>:
                encoder.encode("<$Attribute.name.initialCapitalString$>", "type")<$endprocedure$>

<$procedure writeAttributeEncodeRawSwitchCaseForEnum Attribute$>case  .<$Attribute.name.initialCapitalString$>:
                encoder.encode("<$Attribute.name.initialCapitalString$>", "type")
                encoder.encode(self.rawValue, "value")<$endprocedure$>

<$procedure writeAttributeEncodeAssociatedSwitchCaseForEnum Attribute$>case let .<$Attribute.name.initialCapitalString$>(value):
                encoder.encode("<$Attribute.name.initialCapitalString$>", "type")
                encoder.encode(value<$if Attribute.attributeType == 1800$> >>> <$Attribute.valueTransformerName$>.transform<$endif$>, "value")<$endprocedure$>

<$procedure writeAttributeEncodeSwitchCaseForEnumCase Attribute$><$if userInfo.State.Type$><$call writeAttributeEncodeRawSwitchCaseForEnum Attribute$><$elseif Attribute.userInfo.State.Type$><$call writeAttributeEncodeAssociatedSwitchCaseForEnum Attribute$><$else$><$call writeAttributeEncodeBasicSwitchCaseForEnum Attribute$><$endif$><$endprocedure$>

<$procedure writeRelationshipEncodeBasicSwitchCaseForEnum Relationship$>case .<$Relationship.name.initialCapitalString$>:
                encoder.encode("<$Relationship.name.initialCapitalString$>", "type")<$endprocedure$>

<$procedure writeRelationshipEncodeRawSwitchCaseForEnum Relationship$>case let .<$Relationship.name.initialCapitalString$>:
                encoder.encode("<$Relationship.name.initialCapitalString$>", "type")
                encoder.encode(self.rawValue, "value")<$endprocedure$>

<$procedure writeRelationshipEncodeAssociatedSwitchCaseForEnum Relationship$>case let .<$Relationship.name.initialCapitalString$>(value):
                encoder.encode("<$Relationship.name.initialCapitalString$>", "type")
                encoder.encode(value, "value")<$endprocedure$>

<$procedure writeRelationshipEncodeSwitchCaseForEnumCase Relationship$><$if userInfo.State.Type$><$call writeRelationshipEncodeRawSwitchCaseForEnum Relationship$><$elseif Relationship.destinationEntity.managedObjectClassName$><$call writeRelationshipEncodeAssociatedSwitchCaseForEnum Relationship$><$else$><$call writeRelationshipEncodeBasicSwitchCaseForEnum Relationship$><$endif$><$endprocedure$>

<$procedure Enum$>
<$setmerge typeName = <$managedObjectClassName$>$>
public enum <$typeName$> <$if userInfo.State.Type$> : <$userInfo.State.Type$>, Model<$else$> : Model<$endif$> {


    <$foreach Attribute noninheritedAttributes do$><$call writeEnumCaseForAttribute Attribute$>
    <$endforeach do$><$foreach Relationship noninheritedRelationships do$><$call writeEnumCaseForRelationship Relationship$>
    <$endforeach do$>
}

extension <$typeName$>: Decodable {

    public init?(var decoder: Decoder) {

        <$call writeDecodingMigrationBlock$>

        if let type: String = decoder.decode("type") {

            switch type {
                <$foreach Attribute noninheritedAttributes do$><$call writeAttributeDecodeSwitchCaseForEnumCase Attribute$>
                <$endforeach do$><$foreach Relationship noninheritedRelationships do$><$call writeRelationshipDecodeSwitchCaseForEnumCase Relationship$>
                <$endforeach do$>
                default:
                    return nil
            }
        } else { return nil }
    }
}

extension <$typeName$>: Encodable {

    public func encode(encoder: Encoder) {

        switch self {
            <$foreach Attribute noninheritedAttributes do$><$call writeAttributeEncodeSwitchCaseForEnumCase Attribute$>
            <$endforeach do$><$foreach Relationship noninheritedRelationships do$><$call writeRelationshipEncodeSwitchCaseForEnumCase Relationship$>
            <$endforeach do$>
        }
        <$call writeEncodingVersioningBlock$>
         self.willFinishEncodingWithEncoder(encoder)
    }
}

<$call writeVersionHashExtension $>
<$endprocedure$>

<$procedure writeAttributeProtocolRequirement Attribute$>   var <$Attribute.name$> : <$call getTypeForAttribute Attribute$> { get <$if Attribute.userInfo.State.Immutable == YES$>}<$else$>set }<$endif$>
<$endprocedure$>

<$procedure writeRelationshipProtocolRequirement Relationship$>   var <$Relationship.name$> : <$if Relationship.isToMany$>[<$if Relationship.userInfo.State.CompositionType == Dictionary$>String : <$endif$><$endif$><$Relationship.destinationEntity.managedObjectClassName$><$if Relationship.isToMany$>]<$endif$><$if Relationship.isOptional$>?<$endif$> { get <$if Relationship.userInfo.State.Immutable == YES$>}<$else$>set }<$endif$>
<$endprocedure$>

<$procedure writeCasesForTypes Subtypes$>
    <$foreach Type Subtypes do$><$if Type.isAbstract || Type.userInfo.State.Protocol == YES$><$call writeCasesForTypes Type.subentities$><$else$><$call writeCaseForDecodeType Type$><$endif$><$endforeach do$>
<$endprocedure$>

<$procedure writeCaseForDecodeType Type$>
        case "<$Type.managedObjectClassName$>":
            return <$Type.managedObjectClassName$>.self
<$endprocedure$>

<$procedure Protocol$>
<$setmerge typeName = <$managedObjectClassName$>$>
public protocol <$typeName$><$if hasSuperentity$> : <$superentity.managedObjectClassName$><$else$> : ModelProtocol<$endif$> {

<$foreach Attribute noninheritedAttributes do$><$call writeAttributeProtocolRequirement Attribute$><$endforeach do$>
<$foreach Relationship noninheritedRelationships do$><$call writeRelationshipProtocolRequirement Relationship$><$endforeach do$>

}

/// Mark: Decoding

public extension Decoder {

    public func decode<$typeName$>(key: String) -> <$typeName$>? {
        let data = self.extractData()
        let d = data[key] as? [String : AnyObject]
        return d.flatMap(_decode<$typeName$>)
    }

    public func decode<$typeName$>Array(key: String) -> [<$typeName$>]? {
        let data = self.extractData()
        let d = data[key] as? [[String : AnyObject]]
        return d.flatMap { sequence($0.map(_decode<$typeName$>)) }
    }

    public func decode<$typeName$>Dictionary(key: String) -> [String : <$typeName$>]? {
        let data = self.extractData()
        let d = data[key] as? [String : [String : AnyObject]]
        return d.flatMap { sequence($0.map(_decode<$typeName$>)) }
    }

    private func _decode<$typeName$>(data: [String : AnyObject]) -> <$typeName$>? {
        if let t = <$typeName$>TypeForKey(model_type_key) {
            return t.init(decoder: Decoder(data: data))
        }
        return nil
    }

    private func <$typeName$>TypeForKey(key: String) -> <$typeName$>.Type? {
        switch key {
<$call writeCasesForTypes subentities$>
        default:
            return nil
        }
    }
}

<$endprocedure$>

<$if userInfo.State.Enum == YES$><$call Enum$><$elseif isAbstract || userInfo.State.Protocol == YES$><$call Protocol$><$else$><$call Struct$>
