/************************************************

        WARNING: MACHINE GENERATED FILE

 ************************************************/
import Foundation
import State
<$foreach Attribute noninheritedAttributes do$><$if Attribute.userInfo.State.Import$>import <$Attribute.userInfo.State.Import$>
<$endif$><$endforeach$>

<$set rootTypeName = <$managedObjectClassName$>$>

<$procedure setSuperentityType Entity$><$if Entity.hasSuperentity$><$call setSuperentityType Entity.superentity$><$else$><$set rootTypeName = <$Entity.managedObjectClassName$>$><$endif$><$endprocedure$>

<$if hasSuperentity$><$call setSuperentityType superentity$><$endif$>


<$set transientAttributeCount = 0$><$foreach Attribute noninheritedAttributes do$><$if Attribute.isTransient$><$set transientAttributeCount = transientAttributeCount + 1$><$endif$><$endforeach do$>

<$set functionRequirementCount = 0$><$foreach Attribute attributesByName do$><$if Attribute.userInfo.State.ProtocolRequirementType == func$><$set functionRequirementCount = functionRequirementCount + 1$><$endif$><$endforeach do$>

<$set transientAndFunctionAttributeCount = transientAttributeCount + functionRequirementCount$>

<$set transientRelationshipCount = 0$><$foreach Relationship noninheritedRelationships do$><$if Relationship.isTransient$><$set transientRelationshipCount = transientRelationshipCount + 1$><$endif$><$endforeach do$>

<$procedure getTypeForAttribute Attribute$><$if Attribute.userInfo.State.Type$><$Attribute.userInfo.State.Type$><$elseif Attribute.hasScalarAttributeType$><$if Attribute.scalarAttributeType == Int16 || Attribute.scalarAttributeType == Int32 || Attribute.scalarAttributeType == Int64$>Int<$else$><$Attribute.scalarAttributeType$><$endif$><$else$><$Attribute.objectAttributeType$><$endif$><$if Attribute.isOptional$>?<$endif$><$endprocedure$>

<$procedure writeAttributeDefaultValue Attribute DefaultValue$><$if Attribute.userInfo.State.Type$><$if Attribute.userInfo.State.Type == String$>"<$endif$><$DefaultValue$><$if Attribute.userInfo.State.Type == String$>"<$endif$><$else$><$if Attribute.objectAttributeType == String$>"<$endif$><$DefaultValue$><$if Attribute.objectAttributeType == String$>"<$endif$><$endif$><$endprocedure$>

<$procedure getDefaultExpressionForAttribute Attribute$> <$setlocal default = none$><$if Attribute.userInfo.State.Value$>= <$call writeAttributeDefaultValue Attribute Attribute.userInfo.State.Value$><$elseif Attribute.defaultValue !=$>= <$call writeAttributeDefaultValue Attribute Attribute.defaultValue$><$endif$><$endprocedure$>

<$procedure writeRelationshipDefaultValue Relationship DefaultValue$><$if Relationship.userInfo.State.Type$><$if Relationship.userInfo.State.Type == String$>"<$endif$><$endif$><$DefaultValue$><$if Relationship.userInfo.State.Type$><$if Relationship.userInfo.State.Type == String$>"<$endif$><$endif$><$endprocedure$>

<$procedure getDefaultExpressionForRelationship Relationship$><$if Relationship.userInfo.State.Value$>= <$call writeRelationshipDefaultValue Relationship Relationship.userInfo.State.Value$><$endif$><$endprocedure$>

<$procedure getPropertyDeclarationForAttribute Attribute$><$if Attribute.userInfo.State.Immutable == YES$>public let<$else$>public var<$endif$> <$Attribute.name$><$if  !Attribute.isOptional && (Attribute.userInfo.State.Value || Attribute.defaultValue !=)$><$call getDefaultExpressionForAttribute Attribute$><$else$>: <$call getTypeForAttribute Attribute$><$endif$><$endProcedure$>

<$procedure getPropertyDeclarationForRelationship Relationship$><$if Relationship.userInfo.State.Immutable == YES$>public let<$else$>public var<$endif$> <$Relationship.name$><$if !Relationship.isOptional && Relationship.userInfo.State.Value$> <$call getDefaultExpressionForRelationship Relationship$><$else$>: <$if Relationship.isToMany$>[<$if Relationship.userInfo.State.CompositionType == Dictionary$>String : <$endif$><$endif$><$Relationship.destinationEntity.managedObjectClassName$><$if Relationship.isToMany$>]<$endif$><$if Relationship.isOptional$>?<$endif$><$endif$><$endProcedure$>

<$procedure writeVersionHashExtension$>
extension <$typeName$> {

    /// These are provided from the data model designer
    /// and can be used to determine if the model is
    /// a different version.
    public static func modelVersionHash() -> String {
        return "<$versionHash$>"
    }

    public static func modelVersionHashModifier() -> String? {
        return <$if versionHashModifier$>"<$versionHashModifier$>"<$else$>nil<$endif$>
    }
}<$endprocedure$>


<$procedure writeUserDefaultsSupportBlock$>
//****************************************************************************//
// MARK: UserDefaults support
//****************************************************************************//
extension UserDefaults {

   public func get<$typeName$>(forKey key: String) -> <$typeName$>? {
      guard let dictionary = dictionary(forKey: key) else { return nil }
      return <$typeName$>.decode(dictionary)
   }

   public func get<$typeName$>(forKey key: String) -> [<$typeName$>]? {
      guard let array = array(forKey: key) else { return nil }
      return sequence(array.map(<$typeName$>.decode))
   }

   public func get<$typeName$>(forKey key: String) -> [String : <$typeName$>]? {
      guard let dictionary = dictionary(forKey: key) else { return nil }
      return sequence(dictionary.map { <$typeName$>.decode($0) })
   }

   public func get<$typeName$>(forKey key: String, defaultValue: <$typeName$>) -> <$typeName$> {
      return get<$typeName$>(forKey: key) ?? defaultValue
   }

   public func get<$typeName$>(forKey key: String, defaultValue: [<$typeName$>]) -> [<$typeName$>] {
      return getDecodable(key) ?? defaultValue
   }

   public func get<$typeName$>(forKey key: String,  defaultValue: [String : <$typeName$>]) -> [String : <$typeName$>] {
      return get<$typeName$>(forKey: key) ?? defaultValue
   }

   public func set<$typeName$>(value: <$typeName$>, forKey key: String) {
      set(value.encode(), forKey: key)
   }

   public func set<$typeName$>(value: [<$typeName$>], forKey key: String) {
      set(value.map { $0.encode() }, forKey: key)
   }

   public func set<$typeName$>(value: [String : <$typeName$>], forKey key: String) {
      set(value.map { $0.encode() }, forKey: key)
   }
}
<$endprocedure$>

<$procedure writeKVStoreSupportBlock$>

//****************************************************************************//
// MARK: KVStore support
//****************************************************************************//
extension KVStore {

   public func get<$typeName$>(forKey key: String) -> <$typeName$>? {
      return getValue(forKey: key)
   }

   public func get<$typeName$>(forKey key: String, defaultValue: <$typeName$>) -> <$typeName$> {
      return get<$typeName$>(forKey: key) ?? defaultValue
   }

   public func get<$typeName$>s(forKey key: String) -> [<$typeName$>]? {
      return getValue(forKey: key)
   }

   public func get<$typeName$>s(forKey key: String, defaultValue: [<$typeName$>]) -> [<$typeName$>] {
      return get<$typeName$>s(forKey: key) ?? defaultValue
   }

   public func get<$typeName$>Dictionary(forKey key: String) -> [String : <$typeName$>]? {
      return getValue(forKey: key)
   }

   public func get<$typeName$>Dictionary(forKey key: String, defaultValue: [String : <$typeName$>]) -> [String : <$typeName$>] {
      return get<$typeName$>Dictionary(forKey: key) ?? defaultValue
   }
}
<$endprocedure$>

<$procedure writeUserDefaultsProtocolSupportBlock$>

//****************************************************************************//
// MARK: UserDefault Support
//****************************************************************************//

extension UserDefaults {

   public func get<$typeName$>(forKey key: String) -> <$typeName$>? {
      guard let dictionary = dictionary(forKey: key) else { return nil }
      return decode<$typeName$>(dictionary)
   }

   public func get<$typeName$>(forKey key: String) -> [<$typeName$>]? {
      guard let array = array(forKey: key) else { return nil }
      return sequence(array.map(decode<$typeName$>))
   }

   public func get<$typeName$>(forKey key: String) -> [String : <$typeName$>]? {
      guard let dictionary = dictionary(forKey: key) else { return nil }
      return sequence(dictionary.map { decode<$typeName$>($0) })
   }

   public func get<$typeName$>(forKey key: String, defaultValue: <$typeName$>) -> <$typeName$> {
      return get<$typeName$>(forKey: key) ?? defaultValue
   }

   public func get<$typeName$>(forKey key: String, defaultValue: [<$typeName$>]) -> [<$typeName$>] {
      return get<$typeName$>(forKey: key) ?? defaultValue
   }

   public func get<$typeName$>(forKey key: String,  defaultValue: [String : <$typeName$>]
   ) -> [String : <$typeName$>] {
      return get<$typeName$>(forKey: key) ?? defaultValue
   }

   public func set<$typeName$>(value: <$typeName$>, forKey key: String) {
      set(value.encode(), forKey: key)
   }

   public func set<$typeName$>(value: [<$typeName$>], forKey key: String) {
      set(value.map { $0.encode() }, forKey: key)
   }

   public func set<$typeName$>(value: [String : <$typeName$>], forKey key: String) {
      set(value.map { $0.encode() }, forKey: key)
   }
}
<$endprocedure$>


<$procedure writeKVStoreProtocolSupportBlock$>
//****************************************************************************//
// MARK: KVStore support
//****************************************************************************//
extension KVStore {
   public func get<$typeName$>(forKey key: String) -> <$typeName$>? {
      let keys = seperateKeypath(key)
      let targetKey = keys.keypath == nil ? self : getKey(keys.keypath!)

      if let targetKey = targetKey {
        return targetKey.decode<$typeName$>(keys.valueName)
      }
      else {
         return nil
      }
   }

   public func get<$typeName$>(forKey key: String, defaultValue: <$typeName$>) -> <$typeName$> {
      return get<$typeName$>(forKey: key) ?? defaultValue
   }

   public func get<$typeName$>s(forKey key: String) -> [<$typeName$>]? {
      let keys = seperateKeypath(key)
      let targetKey = keys.keypath == nil ? self : getKey(keys.keypath!)

      if let targetKey = targetKey {
        return targetKey.decode<$typeName$>(keys.valueName)
      }
      else {
         return nil
      }
   }

   public func get<$typeName$>s(forKey key: String, defaultValue: [<$typeName$>]) -> [<$typeName$>] {
      return get<$typeName$>s(forKey: key) ?? defaultValue
   }

   public func get<$typeName$>Dictionary(forKey key: String) -> [String : <$typeName$>]? {
      let keys = seperateKeypath(key)
      let targetKey = keys.keypath == nil ? self : getKey(keys.keypath!)

      if let targetKey = targetKey {
        return targetKey.decode<$typeName$>(keys.valueName)
      }
      else {
         return nil
      }
   }

   public func get<$typeName$>Dictionary(forKey key: String, defaultValue: [String : <$typeName$>]) -> [String : <$typeName$>] {
      return get<$typeName$>Dictionary(forKey: key) ?? defaultValue
   }

   public func setValue(value: <$typeName$>, forKey: String) {
      let keys = seperateKeypath(forKey)

      let targetKey = keys.keypath == nil  ? self : addKey(keys.keypath!)
      targetKey.encode(value, keys.valueName)
   }

   public func setValue(value: [<$typeName$>], forKey: String) {
      let keys = seperateKeypath(forKey)

      let targetKey = keys.keypath == nil  ? self : addKey(keys.keypath!)
      targetKey.encode(value, keys.valueName)
   }

   public func setValue(value: [String : <$typeName$>], forKey: String) {
      let keys = seperateKeypath(forKey)

      let targetKey = keys.keypath == nil  ? self : addKey(keys.keypath!)
      targetKey.encode(value, keys.valueName)
   }

}
<$endprocedure$>

<$procedure writeEncodingVersioningBlock$>
        <$typeName$>.encodeVersionIfNeeded(encoder)
        <$endprocedure$>

<$procedure writeDecodingMigrationBlock$>decoder = <$typeName$>.performMigrationIfNeeded(decoder)<$endprocedure$>

<$procedure Struct$>

<$setmerge typeName = <$managedObjectClassName$>$>
<$setmerge superTypeName = <$if hasSuperentity$><$superentity.managedObjectClassName$><$else$>Model<$endif$>$>

public struct <$typeName$> : <$superTypeName$> {
    <$foreach Attribute attributesByName do$><$if Attribute.userInfo.State.ProtocolRequirementType != func && Attribute.userInfo.State.ProtocolRequirementType != get$><$call getPropertyDeclarationForAttribute Attribute$>
    <$endif$><$endforeach do$><$foreach Relationship relationshipsByName do$><$if Relationship.userInfo.State.ProtocolRequirementType != get$><$call getPropertyDeclarationForRelationship Relationship$><$endif$>
    <$endforeach do$>
}

extension <$typeName$> : Decodable {

   public static func decode(_ decoder: Decoder) -> <$typeName$>? {
      return self.init(decoder: decoder)
   }

    public init?(decoder d: Decoder) {
        var decoder = d
        <$call writeDecodingMigrationBlock$>

<$setlocal hasNonOptionals = 0 $>
<$foreach Attribute attributesByName do$><$if !Attribute.isTransient && Attribute.userInfo.State.ProtocolRequirementType != func && Attribute.userInfo.State.ProtocolRequirementType != get$><$if !Attribute.isOptional$><$setlocal hasNonOptionals = 1$><$endif$><$endif$><$endforeach do$>
<$foreach Relationship relationshipsByName do$><$if !Relationship.isTransient && Relationship.userInfo.State.ProtocolRequirementType != get$><$if !Relationship.isOptional$><$setlocal hasNonOptionals = 1$><$endif$><$endif$><$endforeach do$>

<$if hasNonOptionals == 1$>
         guard
            <$setlocal prop = 0$><$foreach Attribute attributesByName do$><$if !Attribute.isTransient && Attribute.userInfo.State.ProtocolRequirementType != func && Attribute.userInfo.State.ProtocolRequirementType != get$><$if !Attribute.isOptional$><$if prop > 0$>,
            <$endif$><$setlocal prop = prop + 1$>let <$Attribute.name$>: <$call getTypeForAttribute Attribute$> = decoder.decode("<$Attribute.name$>")<$endif$><$endif$><$endforeach do$><$foreach Relationship relationshipsByName do$><$if !Relationship.isTransient &&  Relationship.userInfo.State.ProtocolRequirementType != get$><$if !Relationship.isOptional$><$if prop > 0$>,
            <$endif$><$setlocal prop = prop + 1$>let <$Relationship.name$>: <$if  Relationship.isToMany$>[<$endif$><$if Relationship.userInfo.State.CompositionType == Dictionary$>String : <$endif$><$Relationship.destinationEntity.managedObjectClassName$><$if  Relationship.isToMany$>]<$endif$><$if Relationship.isOptional$>?<$endif$> = decoder.decode<$if Relationship.destinationEntity.isAbstract || Relationship.destinationEntity.userInfo.State.Protocol == YES$><$Relationship.destinationEntity.managedObjectClassName$><$endif$>("<$Relationship.name$>")<$endif$><$endif$><$endforeach do$>
         else { return  nil }
         <$endif$>

        <$foreach Attribute attributesByName do$><$if !Attribute.isTransient && Attribute.userInfo.State.ProtocolRequirementType != func && Attribute.userInfo.State.ProtocolRequirementType != get$><$if Attribute.isOptional$>let <$Attribute.name$>: <$call getTypeForAttribute Attribute$> = decoder.decode("<$Attribute.name$>")<$endif$>
        <$endif$><$endforeach do$><$foreach Relationship relationshipsByName do$><$if !Relationship.isTransient && Relationship.userInfo.State.ProtocolRequirementType != get$><$if Relationship.isOptional$>let <$Relationship.name$>: <$if  Relationship.isToMany$>[<$endif$><$if Relationship.userInfo.State.CompositionType == Dictionary$>String : <$endif$><$Relationship.destinationEntity.managedObjectClassName$><$if  Relationship.isToMany$>]<$endif$><$if Relationship.isOptional$>?<$endif$> = decoder.decode<$if Relationship.destinationEntity.isAbstract || Relationship.destinationEntity.userInfo.State.Protocol == YES$><$Relationship.destinationEntity.managedObjectClassName$><$endif$>("<$Relationship.name$>")<$endif$>
        <$endif$><$endforeach do$>

        <$foreach Attribute attributesByName do$><$if !Attribute.isTransient && Attribute.userInfo.State.ProtocolRequirementType != func && Attribute.userInfo.State.ProtocolRequirementType != get$>self.<$Attribute.name$> = <$Attribute.name$>
        <$endif$><$endforeach do$><$foreach Relationship relationshipsByName do$><$if !Relationship.isTransient && Relationship.userInfo.State.ProtocolRequirementType != get$>self.<$Relationship.name$> = <$Relationship.name$>
        <$endif$><$endforeach do$>didFinishDecoding(decoder: decoder)
    }
}

extension <$typeName$> : Encodable {

    public func encode(_ encoder: Encoder) {
        <$foreach Attribute attributesByName do$><$if !Attribute.isTransient && Attribute.userInfo.State.ProtocolRequirementType != func && Attribute.userInfo.State.ProtocolRequirementType != get$>encoder.encode(<$Attribute.name$>, "<$Attribute.name$>")
        <$endif$><$endforeach do$><$foreach Relationship relationshipsByName do$><$if !Relationship.isTransient && Relationship.userInfo.State.ProtocolRequirementType != get$>encoder.encode(<$Relationship.name$>, "<$Relationship.name$>")
        <$endif$><$endforeach do$>
        <$if hasSuperentity$>encoder.encode("<$typeName$>", "<$rootTypeName$>")<$endif$>
        <$call writeEncodingVersioningBlock$>
        self.willFinishEncoding(encoder: encoder)
    }
}

<$call writeVersionHashExtension $>
<$call writeUserDefaultsSupportBlock$>
<$call writeKVStoreSupportBlock$>
<$endprocedure$>


<$procedure writeRawValueCaseForAttribute Attribute$><$if Attribute.userInfo.State.Value$> = <$if userInfo.State.Type == String$>"<$endif$><$ Attribute.userInfo.State.Value$><$if userInfo.State.Type == String$>"<$endif$><$endif$><$endprocedure$>

<$procedure writeAssociatedValueCaseForAttribute Attribute$><$if Attribute.userInfo.State.Type$>(<$Attribute.userInfo.State.Type$><$if Attribute.isOptional$>?<$endif$>)<$endif$><$endprocedure$>

<$procedure writeEnumCaseForAttribute Attribute$>case <$Attribute.name$> <$if userInfo.State.Type$><$call writeRawValueCaseForAttribute Attribute$><$else$><$call writeAssociatedValueCaseForAttribute Attribute$><$endif$><$endprocedure$>


<$procedure writeRawValueCaseForRelationship Relationship$><$if Relationship.userInfo.State.Value$> = <$if userInfo.State.Type == String$>"<$endif$><$ Relationship.userInfo.State.Value$><$if userInfo.State.Type == String$>"<$endif$><$endif$><$endprocedure$>

<$procedure writeAssociatedValueCaseForRelationship Relationship$><$if Relationship.destinationEntity.managedObjectClassName$>(<$if Relationship.isToMany$>[<$endif$><$Relationship.destinationEntity.managedObjectClassName$><$if Relationship.isToMany$>]<$endif$><$if Relationship.isOptional$>?<$endif$>)<$endif$><$endprocedure$>


<$procedure writeEnumCaseForRelationship Relationship$>case <$Relationship.name$> <$if userInfo.State.Type$><$call writeRawValueCaseForRelationship Relationship$><$else$><$call writeAssociatedValueCaseForRelationship Relationship$><$endif$><$endprocedure$>

<$procedure writeAttributeDecodeAssociatedSwitchCaseForEnumOptional Attribute$>let value: <$Attribute.userInfo.State.Type$>? = decoder.decode("value")
self = <$typeName$>.<$Attribute.name$>(value)
<$endprocedure$>

<$procedure writeAttributeDecodeAssociatedSwitchCaseForEnumNonOptional Attribute$>if let value: <$Attribute.userInfo.State.Type$> = decoder.decode("value") {
self = <$typeName$>.<$Attribute.name$>(value)
} else { return nil }<$endprocedure$>


<$procedure writeAttributeDecodeAssociatedSwitchCaseForEnum Attribute$><$if Attribute.isOptional$><$call writeAttributeDecodeAssociatedSwitchCaseForEnumOptional Attribute$><$else$><$call writeAttributeDecodeAssociatedSwitchCaseForEnumNonOptional Attribute$><$endif$>
<$endprocedure$>

<$procedure writeAttributeDecodeBasicSwitchCaseForEnum Attribute$>self = <$typeName$>.<$Attribute.name$><$endprocedure$>


<$procedure writeAttributeDecodeSwitchCaseForEnumCase Attribute$>case "<$Attribute.name$>":
                   <$if Attribute.userInfo.State.Type$><$call writeAttributeDecodeAssociatedSwitchCaseForEnum Attribute$><$else$><$call writeAttributeDecodeBasicSwitchCaseForEnum Attribute$><$endif$><$endprocedure$>

<$procedure writeRelationshipDecodeAssociatedSwitchCaseForEnumOptional Relationship$>let value: <$if Relationship.isToMany$>[<$endif$><$Relationship.destinationEntity.managedObjectClassName$><$if Relationship.isToMany$>]<$endif$>? = decoder.decode("value")
self = <$typeName$>.<$Relationship.name$>(value)
<$endprocedure$>

<$procedure writeRelationshipDecodeAssociatedSwitchCaseForEnumNonOptional Relationship$>if let value: <$if Relationship.isToMany$>[<$endif$><$Relationship.destinationEntity.managedObjectClassName$><$if Relationship.isToMany$>]<$endif$> = decoder.decode("value") {
self = <$typeName$>.<$Relationship.name$>(value)
} else { return nil }<$endprocedure$>


<$procedure writeRelationshipDecodeAssociatedSwitchCaseForEnum Relationship$><$if Relationship.isOptional$><$call writeRelationshipDecodeAssociatedSwitchCaseForEnumOptional Relationship$><$else$><$call writeRelationshipDecodeAssociatedSwitchCaseForEnumNonOptional Relationship$> <$endif$><$endprocedure$>

<$procedure writeRelationshipDecodeBasicSwitchCaseForEnum Relationship$>self = <$typeName$>.<$Relationship.name$><$endprocedure$>

<$procedure writeRelationshipDecodeRawSwitchCaseForEnum Relationship$>if let value: <$userInfo.State.Type$> = decoder.decode("value"),
                        instance = <$typeName$>(rawValue: value) {
                        instance.didFinishDecoding(decoder: decoder)
                        self = instance
                    } else { return nil }<$endprocedure$>

<$procedure writeRelationshipDecodeSwitchCaseForEnumCase Relationship$>case "<$Relationship.name$>":
                    <$if userInfo.State.Type$><$call writeRelationshipDecodeRawSwitchCaseForEnum Relationship$><$elseif  Relationship.destinationEntity.managedObjectClassName$><$call writeRelationshipDecodeAssociatedSwitchCaseForEnum Relationship$><$else$><$call writeRelationshipDecodeBasicSwitchCaseForEnum Relationship$><$endif$><$endprocedure$>

<$procedure writeAttributeEncodeBasicSwitchCaseForEnum Attribute$>case .<$Attribute.name$>:
                encoder.encode("<$Attribute.name$>", "<$typeName$>")<$endprocedure$>

<$procedure writeAttributeEncodeAssociatedSwitchCaseForEnum Attribute$>case let .<$Attribute.name$>(value):
                encoder.encode("<$Attribute.name$>", "<$typeName$>")
                encoder.encode(value, "value")<$endprocedure$>

<$procedure writeAttributeEncodeSwitchCaseForEnumCase Attribute$><$if Attribute.userInfo.State.Type$><$call writeAttributeEncodeAssociatedSwitchCaseForEnum Attribute$><$else$><$call writeAttributeEncodeBasicSwitchCaseForEnum Attribute$><$endif$><$endprocedure$>

<$procedure writeRelationshipEncodeBasicSwitchCaseForEnum Relationship$>case .<$Relationship.name$>:
                encoder.encode("<$Relationship.name$>", "<$typeName$>")<$endprocedure$>

<$procedure writeRelationshipEncodeRawSwitchCaseForEnum Relationship$>case let .<$Relationship.name$>:
                encoder.encode("<$Relationship.name$>", "<$typeName$>")
                encoder.encode(self.rawValue, "value")<$endprocedure$>

<$procedure writeRelationshipEncodeAssociatedSwitchCaseForEnum Relationship$>case let .<$Relationship.name$>(value):
                encoder.encode("<$Relationship.name$>", "<$typeName$>")
                encoder.encode(value, "value")<$endprocedure$>

<$procedure writeRelationshipEncodeSwitchCaseForEnumCase Relationship$><$if userInfo.State.Type$><$call writeRelationshipEncodeRawSwitchCaseForEnum Relationship$><$elseif Relationship.destinationEntity.managedObjectClassName$><$call writeRelationshipEncodeAssociatedSwitchCaseForEnum Relationship$><$else$><$call writeRelationshipEncodeBasicSwitchCaseForEnum Relationship$><$endif$><$endprocedure$>

<$procedure Enum$>
<$setmerge typeName = <$managedObjectClassName$>$>
public enum <$typeName$> <$if userInfo.State.Type$> : <$userInfo.State.Type$>, Model<$else$> : Model<$endif$> {


    <$foreach Attribute noninheritedAttributes do$><$call writeEnumCaseForAttribute Attribute$>
    <$endforeach do$><$foreach Relationship noninheritedRelationships do$><$call writeEnumCaseForRelationship Relationship$>
    <$endforeach do$>
}

extension <$typeName$>: Decodable {

   public static func decode(_ decoder: Decoder) -> <$typeName$>? {
      return self.init(decoder: decoder)
   }

    public init?(decoder d: Decoder) {
        var decoder = d
        <$call writeDecodingMigrationBlock$>
<$if ! userInfo.State.Type$>
        guard let type: String = decoder.decode("<$typeName$>") else { return nil }
        switch type {
                <$foreach Attribute noninheritedAttributes do$><$call writeAttributeDecodeSwitchCaseForEnumCase Attribute$>
                <$endforeach do$><$foreach Relationship noninheritedRelationships do$><$call writeRelationshipDecodeSwitchCaseForEnumCase Relationship$>
                <$endforeach do$>
                default:
                    return nil
        }
<$else$>        guard let value: <$userInfo.State.Type$> = decoder.decode<$if userInfo.State.Model$><$userInfo.State.Model$><$endif$>("value") else { return nil }
        self.init(rawValue: value)<$endif$>
    }
}

extension <$typeName$>: Encodable {

    public func encode(_ encoder: Encoder) {
<$if ! userInfo.State.Type$>
        switch self {
            <$foreach Attribute noninheritedAttributes do$><$call writeAttributeEncodeSwitchCaseForEnumCase Attribute$>
            <$endforeach do$><$foreach Relationship noninheritedRelationships do$><$call writeRelationshipEncodeSwitchCaseForEnumCase Relationship$>
            <$endforeach do$>
        }
<$else$>        encoder.encode(self.rawValue, "value")<$endif$><$call writeEncodingVersioningBlock$>self.willFinishEncoding(encoder: encoder)
    }
}

<$call writeVersionHashExtension $>
<$call writeUserDefaultsSupportBlock$>
<$call writeKVStoreSupportBlock$>
<$endprocedure$>

<$procedure writeAttributeProtocolFunctionRequirement Attribute$>   <$if Attribute.userInfo.State.Mutating == YES$>mutating <$endif$>func <$Attribute.userInfo.State.Func$><$endprocedure$>


<$procedure writeAttributeProtocolPropertyRequirement Attribute$>   var <$Attribute.name$> : <$call getTypeForAttribute Attribute$> { get <$if Attribute.userInfo.State.ProtocolRequirementType == get$>}<$else$>set }<$endif$><$endprocedure$>

<$procedure writeRelationshipProtocolRequirement Relationship$>   var <$Relationship.name$> : <$if Relationship.isToMany$>[<$if Relationship.userInfo.State.CompositionType == Dictionary$>String : <$endif$><$endif$><$Relationship.destinationEntity.managedObjectClassName$><$if Relationship.isToMany$>]<$endif$><$if Relationship.isOptional$>?<$endif$> { get <$if Relationship.userInfo.State.ProtocolRequirementType == get$>}<$else$>set }<$endif$>
<$endprocedure$>

<$procedure writeCasesForTypes Subtypes$>
    <$foreach Type Subtypes do$><$if Type.isAbstract || Type.userInfo.State.Protocol == YES$><$call writeCasesForTypes Type.subentities$><$else$><$call writeCaseForDecodeType Type$><$endif$><$endforeach do$>
<$endprocedure$>

<$procedure writeCaseForDecodeType Type$>
        case "<$Type.managedObjectClassName$>":
            return <$Type.managedObjectClassName$>.self
<$endprocedure$>

<$procedure Protocol$>
<$setmerge typeName = <$managedObjectClassName$>$>
public protocol <$typeName$><$if hasSuperentity$> : <$superentity.managedObjectClassName$><$else$> : Model<$endif$> <$if userInfo.State.Type$>, <$userInfo.State.Type$><$endif$> {

<$foreach Attribute noninheritedAttributes do$><$if Attribute.userInfo.State.ProtocolRequirementType != func$><$call writeAttributeProtocolPropertyRequirement Attribute$>
<$endif$><$endforeach do$><$foreach Relationship noninheritedRelationships do$><$call writeRelationshipProtocolRequirement Relationship$><$endforeach do$>
<$foreach Attribute noninheritedAttributes do$><$if Attribute.userInfo.State.ProtocolRequirementType == func$><$call writeAttributeProtocolFunctionRequirement Attribute$>
<$endif$><$endforeach do$>


}

func decode<$typeName$>(_ data: AnyObject?) -> <$typeName$>? {

   if let data = data as? [String : AnyObject] {
      let decoder = Decoder(data: data)
      guard let dataTypeKey = data["<$typeName$>"] as? String else { return nil }
      if let t = decoder.<$typeName$>Type(forKey: dataTypeKey) {
         return t.decode(decoder)
      }
      return nil
   }
   return nil
}


// Mark: Decoding

public extension DecoderType {


    public func decode<$typeName$>(_ key: String) -> <$typeName$>? {
        let data = self.data
        let d = data[key] as? [String : AnyObject]
        return d.flatMap(_decode<$typeName$>)
    }

    public func decode<$typeName$>(_ key: String) -> [<$typeName$>]? {
        let data = self.data
        let d = data[key] as? [[String : AnyObject]]
        return d.flatMap { sequence($0.map(_decode<$typeName$>)) }
    }

    public func decode<$typeName$>(_ key: String) -> [String : <$typeName$>]? {
        let data = self.data
        let d = data[key] as? [String : [String : AnyObject]]
        return d.flatMap { sequence($0.map(_decode<$typeName$>)) }
    }

    private func _decode<$typeName$>(data: [String : AnyObject]) -> <$typeName$>? {
        guard let dataTypeKey = data["<$rootTypeName$>"] as? String else { return nil }
        if let t = <$typeName$>Type(forKey: dataTypeKey) {
            return t.decode(Decoder(data: data))
        }
        return nil
    }

    private func <$typeName$>Type(forKey key: String) -> <$typeName$>.Type? {
        switch key {
<$call writeCasesForTypes subentities$>
        default:
            return nil
        }
    }
}

// Mark: Encoding

public extension EncoderType {

    public func encode(element: <$typeName$>?, _ key: String) {
        guard let element = element else { return }
        self.data[key] = element.encode()
    }

    public func encode(element: [<$typeName$>]?, _ key: String) {
       guard let element = element else { return }
       self.data[key] = element.map { $0.encode() }
    }

    public func encode(element: [String : <$typeName$>]?, _ key: String) {
        guard let element = element else { return }
        self.data[key] = element.map { $0.encode() }
    }
}

<$call writeUserDefaultsProtocolSupportBlock$>
<$call writeKVStoreProtocolSupportBlock$>
<$endprocedure$>

<$if userInfo.State.Enum == YES$><$call Enum$><$elseif isAbstract || userInfo.State.Protocol == YES$><$call Protocol$><$else$><$call Struct$>
