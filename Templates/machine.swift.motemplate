/************************************************

        WARNING: MACHINE GENERATED FILE

 ************************************************/
import Foundation
import Spot
<$foreach Attribute noninheritedAttributes do$><$if Attribute.userInfo.Spot.Import$>import <$Attribute.userInfo.Spot.Import$>
<$endif$><$endforeach$>

<$set transientAttributeCount = 0$><$foreach Attribute noninheritedAttributes do$><$if Attribute.isTransient$><$set transientAttributeCount = transientAttributeCount + 1$><$endif$><$endforeach do$>

<$set transientRelationshipCount = 0$><$foreach Relationship noninheritedRelationships do$><$if Relationship.isTransient$><$set transientRelationshipCount = transientRelationshipCount + 1$><$endif$><$endforeach do$>

<$procedure getTypeForAttribute Attribute$><$if Attribute.userInfo.Spot.Type$><$Attribute.userInfo.Spot.Type$><$elseif Attribute.hasScalarAttributeType$><$if Attribute.scalarAttributeType == Int16 || Attribute.scalarAttributeType == Int32 || Attribute.scalarAttributeType == Int64$>Int<$else$><$Attribute.scalarAttributeType$><$endif$><$else$><$Attribute.objectAttributeType$><$endif$><$if Attribute.isOptional$>?<$endif$><$endprocedure$>

<$procedure writeAttributeDefaultValue Attribute DefaultValue$><$if Attribute.userInfo.Spot.Type$><$if Attribute.userInfo.Spot.Type == String$>"<$endif$><$DefaultValue$><$if Attribute.userInfo.Spot.Type == String$>"<$endif$><$else$><$if Attribute.objectAttributeType == String$>"<$endif$><$DefaultValue$><$if Attribute.objectAttributeType == String$>"<$endif$><$endif$><$endprocedure$>

<$procedure getDefaultExpressionForAttribute Attribute$> <$setlocal default = none$><$if Attribute.userInfo.Spot.Value$>= <$call writeAttributeDefaultValue Attribute Attribute.userInfo.Spot.Value$><$elseif Attribute.defaultValue !=$>= <$call writeAttributeDefaultValue Attribute Attribute.defaultValue$><$endif$><$endprocedure$>

<$procedure writeRelationshipDefaultValue Relationship DefaultValue$><$if Relationship.userInfo.Spot.Type$><$if Relationship.userInfo.Spot.Type == String$>"<$endif$><$endif$><$DefaultValue$><$if Relationship.userInfo.Spot.Type$><$if Relationship.userInfo.Spot.Type == String$>"<$endif$><$endif$><$endprocedure$>

<$procedure getDefaultExpressionForRelationship Relationship$><$if Relationship.userInfo.Spot.Value$>= <$call writeRelationshipDefaultValue Relationship Relationship.userInfo.Spot.Value$><$endif$><$endprocedure$>

<$procedure getPropertyDeclarationForAttribute Attribute$><$if Attribute.userInfo.Spot.Immutable == YES$>public let<$else$>public var<$endif$> <$Attribute.name$><$if  !Attribute.isOptional && (Attribute.userInfo.Spot.Value || Attribute.defaultValue !=)$><$call getDefaultExpressionForAttribute Attribute$><$else$>: <$call getTypeForAttribute Attribute$><$endif$><$endProcedure$>

<$procedure getPropertyDeclarationForRelationship Relationship$><$if Relationship.userInfo.Spot.Immutable == YES$>public let<$else$>public var<$endif$> <$Relationship.name$><$if !Relationship.isOptional && Relationship.userInfo.Spot.Value$> <$call getDefaultExpressionForRelationship Relationship$><$else$>: <$if Relationship.isToMany$>[<$endif$><$Relationship.destinationEntity.managedObjectClassName$><$if Relationship.isToMany$>]<$endif$><$if Relationship.isOptional$>?<$endif$><$endif$><$endProcedure$>

<$procedure writeVersionHashExtension$>
extension <$managedObjectClassName$> {
    /**
    These are provided from the data model designer
    and can be used to determine if the model is
    a different version.
    */
    static var modelVersionHash: String {
        return "<$versionHash$>"
    }

    static var modelVersionHashModifier: String? {
        return <$if versionHashModifier$>"<$versionHashModifier$>"<$else$>nil<$endif$>
    }
}<$endprocedure$>

<$procedure writeEncodingVersioningBlock$>
        if <$managedObjectClassName$>.shouldEncodeVersion {
                encoder.encode(<$managedObjectClassName$>.version(), forKey:<$managedObjectClassName$>.versionKey)
        }<$endprocedure$>

<$procedure writeDecodingMigrationBlock$>
        if <$managedObjectClassName$>.shouldMigrateIfNeeded {
            if let dataVersion: AnyObject = decoder.decode(<$managedObjectClassName$>.versionKey) {
                if <$managedObjectClassName$>.needsMigration(dataVersion) {
                   let migratedData = <$managedObjectClassName$>.migrateDataForDecoding(decoder.extractData(), dataVersion: dataVersion)
                    decoder = Decoder(data: migratedData)
                }
            }
        }<$endprocedure$>

<$if userInfo.Spot.Enum != YES$>
public struct <$managedObjectClassName$><$if hasCustomSuperentity$>: <$customSuperentity$><$endif$> {
    <$foreach Attribute noninheritedAttributes do$><$call getPropertyDeclarationForAttribute Attribute$>
    <$endforeach do$><$foreach Relationship noninheritedRelationships do$><$call getPropertyDeclarationForRelationship Relationship$>
    <$endforeach do$>

    public init(<$foreach Attribute noninheritedAttributes do$><$if !Attribute.isTransient$><$Attribute.name$>: <$call getTypeForAttribute Attribute$><$if (AttributeIndex + 1) < (noninheritedAttributes.@count - transientAttributeCount)$>, <$endif$><$endif$><$endforeach do$><$if noninheritedAttributes.@count - transientAttributeCount > 0 && noninheritedRelationships.@count - transientRelationshipCount > 0$>, <$endif$><$foreach Relationship noninheritedRelationships do$><$if !Relationship.isTransient$><$if ! Relationship.isToMany$><$Relationship.name$>: <$Relationship.destinationEntity.managedObjectClassName$><$if Relationship.isOptional$>?<$endif$><$if (RelationshipIndex + 1 < noninheritedRelationships.@count - transientRelationshipCount) $>, <$endif$><$else$><$Relationship.name$>: [<$Relationship.destinationEntity.managedObjectClassName$>]<$if Relationship.isOptional$>?<$endif$><$if (RelationshipIndex + 1 < noninheritedRelationships.@count - transientRelationshipCount) $>, <$endif$><$endif$><$endif$><$endforeach do$>) {

    <$foreach Attribute noninheritedAttributes do$><$if !Attribute.isTransient$>self.<$Attribute.name$> = <$Attribute.name$><$endif$>
    <$endforeach do$><$foreach Relationship noninheritedRelationships do$><$if !Relationship.isTransient$>self.<$Relationship.name$> = <$Relationship.name$><$endif$>
    <$endforeach do$>
    }
}

extension <$managedObjectClassName$> : Decodable {

    static func create<$foreach Attribute noninheritedAttributes do$><$if !Attribute.isTransient$>(<$Attribute.name$>: <$call getTypeForAttribute Attribute$>)<$endif$><$endforeach do$><$foreach Relationship noninheritedRelationships do$><$if !Relationship.isTransient$><$if ! Relationship.isToMany$>(<$Relationship.name$>: <$Relationship.destinationEntity.managedObjectClassName$><$if Relationship.isOptional$>?<$endif$>)<$else$>(<$Relationship.name$>: [<$Relationship.destinationEntity.managedObjectClassName$>]<$if Relationship.isOptional$>?<$endif$>)<$endif$><$endif$><$endforeach do$> -> <$managedObjectClassName$>  {
        return <$managedObjectClassName$>(<$foreach Attribute noninheritedAttributes do$><$if !Attribute.isTransient$><$Attribute.name$>: <$Attribute.name$><$if AttributeIndex + 1 < noninheritedAttributes.@count - transientAttributeCount$>, <$endif$><$endif$><$endforeach do$><$if (noninheritedAttributes.@count - transientAttributeCount) > 0 && (noninheritedRelationships.@count - transientRelationshipCount) > 0$>, <$endif$><$foreach Relationship noninheritedRelationships do$><$if !Relationship.isTransient$><$Relationship.name$>: <$Relationship.name$><$if (RelationshipIndex + 1 < noninheritedRelationships.@count - transientRelationshipCount) $>, <$endif$><$endif$><$endforeach do$>)
    }

    public init?(var decoder: Decoder) {

        <$call writeDecodingMigrationBlock$>

        let instance: <$managedObjectClassName$>? = <$managedObjectClassName$>.create
        <$setlocal firstNonTransientAttribute = 0$><$setlocal firstNonTransientRelationship = 0$><$foreach Attribute noninheritedAttributes do$><$if !Attribute.isTransient$><$if firstNonTransientAttribute == 0$><$setlocal firstNonTransientAttribute = 1$><$else$><$setlocal firstNonTransientAttribute = 2$><$endif$><$if firstNonTransientAttribute == 1$><^><$else$><*><$endif$> decoder.decode("<$Attribute.name$>")<$if Attribute.attributeType == 1800$> >>> <$Attribute.valueTransformerName$>.reverseTransform<$endif$><$if Attribute.isOptional$> >>> asOptional<$endif$><$endif$>
        <$endforeach do$><$foreach Relationship noninheritedRelationships do$><$if !Relationship.isTransient$><$if firstNonTransientRelationship == 0$><$setlocal firstNonTransientRelationship = 1$><$else$><$setlocal firstNonTransientRelationship = 2$><$endif$><$if firstNonTransientRelationship == 1 && firstNonTransientAttribute == 0$><^><$else$><*><$endif$> decoder.decodeModel<$if Relationship.isToMany$>Array<$endif$>("<$Relationship.name$>")<$if Relationship.isOptional$> >>> asOptional<$endif$><$endif$>
        <$endforeach do$>
        if let i = instance {
            i.didFinishDecodingWithDecoder(decoder)
            self = i
        } else { return nil }
    }
}

extension <$managedObjectClassName$> : Encodable {

    public func encode(encoder: Encoder) {
        <$foreach Attribute noninheritedAttributes do$><$if !Attribute.isTransient$>encoder.encode(self.<$Attribute.name$><$if Attribute.attributeType == 1800$> >>> <$Attribute.valueTransformerName$>.transform<$endif$>, forKey: "<$Attribute.name$>")
        <$endif$><$endforeach do$><$foreach Relationship noninheritedRelationships do$><$if !Relationship.isTransient$>encoder.encode(self.<$Relationship.name$>, forKey: "<$Relationship.name$>")
        <$endif$><$endforeach do$>
        <$call writeEncodingVersioningBlock$>
        self.willFinishEncodingWithEncoder(encoder)
    }
}

<$call writeVersionHashExtension $>
<$endif$>


<$procedure writeRawValueCaseForAttribute Attribute$><$if Attribute.userInfo.Spot.Value$> = <$if userInfo.Spot.Type == String$>"<$endif$><$ Attribute.userInfo.Spot.Value$><$if userInfo.Spot.Type == String$>"<$endif$><$endif$><$endprocedure$>

<$procedure writeAssociatedValueCaseForAttribute Attribute$><$if Attribute.userInfo.Spot.Type$>(<$Attribute.userInfo.Spot.Type$><$if Attribute.isOptional$>?<$endif$>)<$endif$><$endprocedure$>

<$procedure writeEnumCaseForAttribute Attribute$>case <$Attribute.name.initialCapitalString$> <$if userInfo.Spot.Type$><$call writeRawValueCaseForAttribute Attribute$><$else$><$call writeAssociatedValueCaseForAttribute Attribute$><$endif$><$endprocedure$>


<$procedure writeRawValueCaseForRelationship Relationship$><$if Relationship.userInfo.Spot.Value$> = <$if userInfo.Spot.Type == String$>"<$endif$><$ Relationship.userInfo.Spot.Value$><$if userInfo.Spot.Type == String$>"<$endif$><$endif$><$endprocedure$>

<$procedure writeAssociatedValueCaseForRelationship Relationship$><$if Relationship.destinationEntity.managedObjectClassName$>(<$if Relationship.isToMany$>[<$endif$><$Relationship.destinationEntity.managedObjectClassName$><$if Relationship.isToMany$>]<$endif$><$if Relationship.isOptional$>?<$endif$>)<$endif$><$endprocedure$>


<$procedure writeEnumCaseForRelationship Relationship$>case <$Relationship.name.initialCapitalString$> <$if userInfo.Spot.Type$><$call writeRawValueCaseForRelationship Relationship$><$else$><$call writeAssociatedValueCaseForRelationship Relationship$><$endif$><$endprocedure$>


<$procedure writeAttributeDecodeAssociatedSwitchCaseForEnum Attribute$>if let value: <$Attribute.userInfo.Spot.Type$><$if Attribute.isOptional$>?<$endif$> = decoder.decode("value")<$if Attribute.attributeType == 1800$> >>> <$Attribute.valueTransformerName$>.reverseTransform<$endif$><$if Attribute.isOptional$> >>> asOptional<$endif$> {
                        self = <$managedObjectClassName$>.<$Attribute.name.initialCapitalString$>(value)
                    } else { return nil }<$endprocedure$>

<$procedure writeAttributeDecodeBasicSwitchCaseForEnum Attribute$>self = <$managedObjectClassName$>.<$Attribute.name.initialCapitalString$><$endprocedure$>

<$procedure writeAttributeDecodeRawSwitchCaseForEnum Attribute$>if let value: <$userInfo.Spot.Type$> = decoder.decode("value"),
                        instance = <$managedObjectClassName$>(rawValue: value) {
                        instance.didFinishDecodingWithDecoder(decoder)
                        self = instance
                    } else { return nil }<$endprocedure$>

<$procedure writeAttributeDecodeSwitchCaseForEnumCase Attribute$>case "<$Attribute.name.initialCapitalString$>":
                    <$if userInfo.Spot.Type$><$call writeAttributeDecodeRawSwitchCaseForEnum Attribute$><$elseif Attribute.userInfo.Spot.Type$><$call writeAttributeDecodeAssociatedSwitchCaseForEnum Attribute$><$else$><$call writeAttributeDecodeBasicSwitchCaseForEnum Attribute$><$endif$><$endprocedure$>

<$procedure writeRelationshipDecodeAssociatedSwitchCaseForEnum Relationship$>if let value: <$if Relationship.isToMany$>[<$endif$><$Relationship.destinationEntity.managedObjectClassName$><$if Relationship.isToMany$>]<$endif$><$if Relationship.isOptional$>?<$endif$> = decoder.decodeModel<$if Relationship.isToMany$>Array<$endif$>("value") <$if Relationship.isOptional$>>>> asOptional<$endif$>{
                        self = <$managedObjectClassName$>.<$Relationship.name.initialCapitalString$>(value)
                    } else { return nil }<$endprocedure$>

<$procedure writeRelationshipDecodeBasicSwitchCaseForEnum Relationship$>self = <$managedObjectClassName$>.<$Relationship.name.initialCapitalString$><$endprocedure$>

<$procedure writeRelationshipDecodeRawSwitchCaseForEnum Relationship$>if let value: <$userInfo.Spot.Type$> = decoder.decodeModel<$if Relationship.isToMany$>Array<$endif$>("value"),
                        instance = <$managedObjectClassName$>(rawValue: value) {
                        instance.didFinishDecodingWithDecoder(decoder)
                        self = instance
                    } else { return nil }<$endprocedure$>

<$procedure writeRelationshipDecodeSwitchCaseForEnumCase Relationship$>case "<$Relationship.name.initialCapitalString$>":
                    <$if userInfo.Spot.Type$><$call writeRelationshipDecodeRawSwitchCaseForEnum Relationship$><$elseif  Relationship.destinationEntity.managedObjectClassName$><$call writeRelationshipDecodeAssociatedSwitchCaseForEnum Relationship$><$else$><$call writeRelationshipDecodeBasicSwitchCaseForEnum Relationship$><$endif$><$endprocedure$>

<$procedure writeAttributeEncodeBasicSwitchCaseForEnum Attribute$>case let .<$Attribute.name.initialCapitalString$>:
                encoder.encode("<$Attribute.name.initialCapitalString$>", forKey: "type")<$endprocedure$>

<$procedure writeAttributeEncodeRawSwitchCaseForEnum Attribute$>case let .<$Attribute.name.initialCapitalString$>:
                encoder.encode("<$Attribute.name.initialCapitalString$>", forKey: "type")
                encoder.encode(self.rawValue, forKey: "value")<$endprocedure$>

<$procedure writeAttributeEncodeAssociatedSwitchCaseForEnum Attribute$>case let .<$Attribute.name.initialCapitalString$>(value):
                encoder.encode("<$Attribute.name.initialCapitalString$>", forKey: "type")
                encoder.encode(value<$if Attribute.attributeType == 1800$> >>> <$Attribute.valueTransformerName$>.transform<$endif$>, forKey: "value")<$endprocedure$>

<$procedure writeAttributeEncodeSwitchCaseForEnumCase Attribute$><$if userInfo.Spot.Type$><$call writeAttributeEncodeRawSwitchCaseForEnum Attribute$><$elseif Attribute.userInfo.Spot.Type$><$call writeAttributeEncodeAssociatedSwitchCaseForEnum Attribute$><$else$><$call writeAttributeEncodeBasicSwitchCaseForEnum Attribute$><$endif$><$endprocedure$>

<$procedure writeRelationshipEncodeBasicSwitchCaseForEnum Relationship$>case let .<$Relationship.name.initialCapitalString$>:
                encoder.encode("<$Relationship.name.initialCapitalString$>", forKey: "type")<$endprocedure$>

<$procedure writeRelationshipEncodeRawSwitchCaseForEnum Relationship$>case let .<$Relationship.name.initialCapitalString$>:
                encoder.encode("<$Relationship.name.initialCapitalString$>", forKey: "type")
                encoder.encode(self.rawValue, forKey: "value")<$endprocedure$>

<$procedure writeRelationshipEncodeAssociatedSwitchCaseForEnum Relationship$>case let .<$Relationship.name.initialCapitalString$>(value):
                encoder.encode("<$Relationship.name.initialCapitalString$>", forKey: "type")
                encoder.encode(value, forKey: "value")<$endprocedure$>

<$procedure writeRelationshipEncodeSwitchCaseForEnumCase Relationship$><$if userInfo.Spot.Type$><$call writeRelationshipEncodeRawSwitchCaseForEnum Relationship$><$elseif Relationship.destinationEntity.managedObjectClassName$><$call writeRelationshipEncodeAssociatedSwitchCaseForEnum Relationship$><$else$><$call writeRelationshipEncodeBasicSwitchCaseForEnum Relationship$><$endif$><$endprocedure$>



<$if userInfo.Spot.Enum == YES$>
public enum <$managedObjectClassName$><$if userInfo.Spot.Type$>: <$userInfo.Spot.Type$><$endif$> {
    <$foreach Attribute noninheritedAttributes do$><$call writeEnumCaseForAttribute Attribute$>
    <$endforeach do$><$foreach Relationship noninheritedRelationships do$><$call writeEnumCaseForRelationship Relationship$>
    <$endforeach do$>
}

extension <$managedObjectClassName$>: Decodable {

    public init?(var decoder: Decoder) {

        <$call writeDecodingMigrationBlock$>

        if let type: String = decoder.decode("type") {

            switch type {
                <$foreach Attribute noninheritedAttributes do$><$call writeAttributeDecodeSwitchCaseForEnumCase Attribute$>
                <$endforeach do$><$foreach Relationship noninheritedRelationships do$><$call writeRelationshipDecodeSwitchCaseForEnumCase Relationship$>
                <$endforeach do$>
                default:
                    return nil
            }
        } else { return nil }
    }
}

extension <$managedObjectClassName$>: Encodable {

    public func encode(encoder: Encoder) {

        switch self {
            <$foreach Attribute noninheritedAttributes do$><$call writeAttributeEncodeSwitchCaseForEnumCase Attribute$>
            <$endforeach do$><$foreach Relationship noninheritedRelationships do$><$call writeRelationshipEncodeSwitchCaseForEnumCase Relationship$>
            <$endforeach do$>
        }
         self.willFinishEncodingWithEncoder(encoder)
    }
}

<$call writeVersionHashExtension $>
<$endif$>


