/************************************************

            MACHINE GENERATED FILE

 ************************************************/

import Spot

<$procedure getTypeForAttribute Attribute$><$if Attribute.userInfo.Spot.Type$><$Attribute.userInfo.Spot.Type$><$elseif Attribute.hasScalarAttributeType$><$if Attribute.scalarAttributeType == Int16 || Attribute.scalarAttributeType == Int32 || Attribute.scalarAttributeType == Int64$>Int<$else$><$Attribute.scalarAttributeType$><$endif$><$else$><$Attribute.objectAttributeType$><$endif$><$if Attribute.isOptional$>?<$endif$><$endprocedure$>

<$procedure writeAttributeDefaultValue Attribute DefaultValue$><$if Attribute.userInfo.Spot.Type$><$if Attribute.userInfo.Spot.Type == String$>"<$endif$><$DefaultValue$><$if Attribute.userInfo.Spot.Type == String$>"<$endif$><$else$><$if Attribute.objectAttributeType == String$>"<$endif$><$DefaultValue$><$if Attribute.objectAttributeType == String$>"<$endif$><$endif$><$endprocedure$>

<$procedure getDefaultExpressionForAttribute Attribute$> <$setlocal default = none$><$if Attribute.userInfo.Spot.Default$>= <$call writeAttributeDefaultValue Attribute Attribute.userInfo.Spot.Default$><$elseif Attribute.defaultValue !=$>= <$call writeAttributeDefaultValue Attribute Attribute.defaultValue$><$endif$><$endprocedure$>

<$procedure writeRelationshipDefaultValue Relationship DefaultValue$><$if Relationship.userInfo.Spot.Type$><$if Relationship.userInfo.Spot.Type == String$>"<$endif$><$endif$><$DefaultValue$><$if Relationship.userInfo.Spot.Type$><$if Relationship.userInfo.Spot.Type == String$>"<$endif$><$endif$><$endif$><$endprocedure$>

<$procedure getDefaultExpressionForRelationship Relationship$><$if Relationship.userInfo.Spot.Default$>= <$call writeRelationshipDefaultValue Relationship Relationship.userInfo.Spot.Default$><$endif$><$endprocedure$>

<$procedure writeVersionHashExtension$>
extension <$managedObjectClassName$> {
    /**
    These are provided from the data model designer
    and can be used to determine if the model is
    a different version.
    */
    static var modelVersionHash: String {
        return "<$versionHash$>"
    }

    static var modelVersionHashModifier: String? {
        return <$if versionHashModifier$>"<$versionHashModifier$>"<$else$>nil<$endif$>
    }
}<$endprocedure$>

<$procedure writeEncodingVersioningBlock$>
        if <$managedObjectClassName$>.shouldEncodeVersion {
                encoder.encode(<$managedObjectClassName$>.version, forKey:<$managedObjectClassName$>.versionKey)
        }<$endprocedure$>

<$procedure writeDecodingMigrationBlock$>
        if <$managedObjectClassName$>.shouldMigrateIfNeeded {
            if let dataVersion: AnyObject = decoder.decode(<$managedObjectClassName$>.versionKey) {
                if <$managedObjectClassName$>.needsMigration(dataVersion) {
                   let migratedData = <$managedObjectClassName$>.migrateDataForDecoding(decoder.extractData(), dataVersion: dataVersion)
                    decoder = Decoder(data: migratedData)
                }
            }
        }<$endprocedure$>


<$if userInfo.Spot.Enum != YES$>
public struct <$managedObjectClassName$><$if hasCustomSuperentity$>: <$customSuperentity$><$endif$> {
    <$foreach Attribute noninheritedAttributes do$><$if Attribute.userInfo.Spot.Immutable == YES$>public let<$else$>public var<$endif$> <$Attribute.name$>: <$call getTypeForAttribute Attribute$>
    <$endforeach do$><$foreach Relationship noninheritedRelationships do$><$if ! Relationship.isToMany$>public var <$Relationship.name$>: <$Relationship.destinationEntity.managedObjectClassName$><$if Relationship.isOptional$>?<$endif$>
    <$else$>public var <$Relationship.name$>: [<$Relationship.destinationEntity.managedObjectClassName$>]<$if Relationship.isOptional$>?<$endif$> 
    <$endif$><$endforeach do$>

    public init(<$foreach Attribute noninheritedAttributes do$><$Attribute.name$>: <$call getTypeForAttribute Attribute$><$if AttributeIndex + 1 < noninheritedAttributes.@count$>, <$endif$><$endforeach do$><$if noninheritedAttributes.@count > 0 && noninheritedRelationships.@count > 0$>, <$endif$><$foreach Relationship noninheritedRelationships do$><$if ! Relationship.isToMany$><$Relationship.name$>: <$Relationship.destinationEntity.managedObjectClassName$><$if Relationship.isOptional$>?<$endif$><$if (RelationshipIndex + 1 < noninheritedRelationships.@count) $>, <$endif$><$else$><$Relationship.name$>: [<$Relationship.destinationEntity.managedObjectClassName$>]<$if Relationship.isOptional$>?<$endif$><$if (RelationshipIndex + 1 < noninheritedRelationships.@count) $>, <$endif$><$endif$><$endforeach do$>) {

    <$foreach Attribute noninheritedAttributes do$>self.<$Attribute.name$> = <$Attribute.name$>
    <$endforeach do$><$foreach Relationship noninheritedRelationships do$>self.<$Relationship.name$> = <$Relationship.name$>
    <$endforeach do$>
    }
}

extension <$managedObjectClassName$> : Decodable {

    static func create<$foreach Attribute noninheritedAttributes do$>(<$Attribute.name$>: <$call getTypeForAttribute Attribute$>)<$endforeach do$><$foreach Relationship noninheritedRelationships do$><$if ! Relationship.isToMany$>(<$Relationship.name$>: <$Relationship.destinationEntity.managedObjectClassName$><$if Relationship.isOptional$>?<$endif$>)<$else$>(<$Relationship.name$>: [<$Relationship.destinationEntity.managedObjectClassName$>]<$if Relationship.isOptional$>?<$endif$>)<$endif$><$endforeach do$> -> <$managedObjectClassName$>  {
        return <$managedObjectClassName$>(<$foreach Attribute noninheritedAttributes do$><$Attribute.name$>: <$Attribute.name$><$if AttributeIndex + 1 < noninheritedAttributes.@count$>, <$endif$><$endforeach do$><$if noninheritedAttributes.@count > 0 && noninheritedRelationships.@count > 0$>, <$endif$><$foreach Relationship noninheritedRelationships do$><$Relationship.name$>: <$Relationship.name$><$if (RelationshipIndex + 1 < noninheritedRelationships.@count) $>, <$endif$><$endforeach do$>)
    }

    public init?(var decoder: Decoder) {

        <$call writeDecodingMigrationBlock$>

        let instance: <$managedObjectClassName$>? = <$managedObjectClassName$>.create
        <$foreach Attribute noninheritedAttributes do$><$if AttributeIndex == 0$><^><$else$><*><$endif$> decoder.decode("<$Attribute.name$>")<$if Attribute.attributeType == 1800$> >>> <$Attribute.valueTransformerName$>.reverseTransform<$endif$><$if Attribute.isOptional$> >>> asOptional<$endif$>
        <$endforeach do$><$foreach Relationship noninheritedRelationships do$><$if indexOfRelationship == 0 && noninheritedAttributes.@count == 0$><^><$else$><*><$endif$> decoder.decodeModel<$if Relationship.isToMany$>Array<$endif$>("<$Relationship.name$>")<$if Relationship.isOptional$> >>> asOptional<$endif$>
        <$endforeach do$>
        if let i = instance {
            i.didFinishDecodingWithDecoder(decoder)
            self = i
        } else { return nil }
    }
}

extension <$managedObjectClassName$> : Encodable {

    public func encode(encoder: Encoder) {
        <$foreach Attribute noninheritedAttributes do$>encoder.encode(self.<$Attribute.name$><$if Attribute.attributeType == 1800$> >>> <$Attribute.valueTransformerName$>.transform<$endif$>, forKey: "<$Attribute.name$>")
        <$endforeach do$><$foreach Relationship noninheritedRelationships do$>encoder.encode(self.<$Relationship.name$>, forKey: "<$Relationship.name$>")
        <$endforeach do$>
        <$call writeEncodingVersioningBlock$>
        self.willFinishEncodingWithEncoder(encoder)
    }
}

<$call writeVersionHashExtension $>
<$endif$>

<$if userInfo.Spot.Enum == YES$>

public enum <$managedObjectClassName$><$if userInfo.Spot.Type$>: <$userInfo.Spot.Type$><$endif$> {

    <$foreach Attribute noninheritedAttributes do$>case <$Attribute.name.initialCapitalString$><$if Attribute.userInfo.Spot.Value$> = <$if userInfo.Spot.Type == String$>"<$endif$><$if Attribute.userInfo.Spot.Value$><$ Attribute.userInfo.Spot.Value$><$endif$><$if userInfo.Spot.Type == String$>"<$endif$><$endif$>
    <$endforeach do$>
}

extension <$managedObjectClassName$>: Decodable {

    static func create(rawValue: <$userInfo.Spot.Type$>) -> <$managedObjectClassName$>?{
        return <$managedObjectClassName$>(rawValue: rawValue)
    }

    public init?(var decoder: Decoder) {

        <$call writeDecodingMigrationBlock$>
        if let rawValue: <$userInfo.Spot.Type$>  = decoder.decode("value"),
            instance = <$managedObjectClassName$>(rawValue: rawValue) {
            self = instance
        } else { return nil }
    }
}

extension <$managedObjectClassName$>: Encodable {

    public func encode(encoder: Encoder) {
        encoder.encode(self.rawValue, forKey: "value")
        <$call writeEncodingVersioningBlock$>
        self.willFinishEncodingWithEncoder(encoder)
    }
}

<$call writeVersionHashExtension $>
<$endif$>


